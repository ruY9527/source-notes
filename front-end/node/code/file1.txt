三人行，必有我师则其善者而从之，其不善着而改之。
在看了网上很多相关的文章，很多都是懵逼看完，并不是说各位前辈们写得不好，
而是说实在不容易在一两次阅读中理解透。我在阅读了一些文章后，自己整理总结和绘制了一些相关的图，个人认为会更容易接受和理解，所以分享在此。也因此以下的所有的理解和图解都是出于个人的理解，如果有错误的地方，请各位前辈务必见谅，并辛苦在下方提出和纠错，我实在担心自己不成熟的理论底子会误导了其余的小兄弟。
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
一开始，先说说为何这个知识点为什么理解起来这么乱个人感觉原因有三：JS内函数即对象。
Function对象和Object对象这两个内置对象的特殊性。
很多讲解图的指向一眼下去花里胡哨，看着都头疼[手动狗头]。
再说说，为何网上各位前辈的相关文章都难以参透很多前辈在讲解相关知识点的时候都是从__proto__开始讲起，但在我看来，__proto__与prototype关系之密切是无法单独提出来讲的（单独讲就意味着难以理解）；而prototype与constructor又有密切关系，这就造成一种很尴尬的处境，要先讲__proto__就必然需要同时讲解prototype和constructor属性，这个也就是为何对于小白的我们而言这些概念是那么的难以理解。（以上个人看法，仅供参考）然后在讲讲我个人采取的理解方式为了更轻松、更有动力地理解透，我采用从constructor到__proto__原型链一步步“拆解”的方式去理解，希望有好的效果。文章内容如下：
先理解为什么“函数即对象”
constructor其实很纯粹
prototype是为何而出现
真正的constructor属性藏在哪
__proto__让实例能找到自己的原型对象
究竟何为原型链
原型链引出新的继承方式 
学了要用系列 | 手写一个new
总结
① 当任意一个普通函数用于创建一类对象时，它就被称作构造函数，或构造器。function Person() {}
var person1 = new Person()
var person2 = new Person()
复制代码上面代码Person( )就是person1和person2的构造函数。② 可以通过对象.constructor拿到创建该实例对象的构造函数。console.log(person1.constructor) // 结果输出: [Function: Person]
复制代码Person函数就是person1对象的构造函数。③ Function函数和Object函数是JS内置对象，也叫内部类，JS自己封装好的类，所以很多莫名其妙、意想不到的设定其实无需过分纠结，官方动作，神仙操作。④ 原型对象即实例对象自己构造函数内的prototype对象。

作者：歡進
链接：https://juejin.cn/post/6844903837623386126
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。