# React进阶

1. 组件运行的周期？
   * 初始化： render()--->虚拟DOM---> ReactDom.render()--->真实DOM
   * 更新：     render()--->生成新的虚拟DOM---> diff算法---> 定位出两次虚拟DOM的差异--->ReactDom.render()--->真实DOM
2. react中的组件化？
   * react中，几乎所有的内容都可以被抽离为组件，每个组件即是封闭的，也是开放的
   * “==封闭==”：针对**渲染工作流**来说的。组件只处理其内部的渲染逻辑
   * “==开放==”：针对**组件间通信**来说的。组件间通信基于单向数据流，而组件间的通信会改变双方内部的数据，进而对渲染结果产生影响
3. React为何两次求变？
   * Fiber是React16对React核心算法的一次重写
   * Fiber会使原本同步的渲染过程变成可以被打断的异步渲染模式
   * React16的生命周期被划分为render和commit两个阶段：
     * render阶段：纯净且无副作用；可能会被react暂停，中止或重新启用
     * pre-commit阶段: 可以读取DOM
     * commit阶段：可以使用DOM, 运行副作用，安排更新
4. 生命周期“废旧立新”背后的思考？
   * render阶段是允许暂停、中止和重启的。当一个任务执行到一半被打断后，下一次渲染线程抢回主动权时，这个任务会执行一遍整个任务，而非接着上次代码执行。这就导致==render阶段的生命周期是有可能被重复执行的==
   * 所以react16中废除了一些生命周期：
     * componentWillMount
     * componentWillUpdate
     * componentWillReceiveProps
     * 它们都处于render阶段，都可能被重复执行；比如componentWillxxx被打断+重启多次后，就会发出多个付款请求。避免开发者接触this，就会避免多种危险的bug
   * react16改造生命周期的主要动机，就是为了配合Fiber架构带来的异步渲染机制
5. react中的组件间通信？
   * 基于props的单向数据流
   * 父-子组件通信: props 
   * 子-父组件通信: 父组件传递给子组件的是一个绑定了自身上下文的函数，子组件在调用该函数时，将数据以函数入参的形式传出去
   * 兄弟组件通信：借助同层级的父组件进行数据传递
   * 利用“发布-订阅”模式驱动数据流
   * 使用context 维护全局状态
   * 三方数据流框架 Redux
6. react-hooks的设计动机与工作模式？
   * 类组件和函数组件对比：
     * 类组件需要继承class
     * 类组件可以访问生命周期方法
     * 类组件可以获取到实例化的this
     * 类组件可以维护state(状态)
   * 类组件--包裹在面向对象思想下的“重装战舰”
     * 是一种面向对象编程思想的一种表征，开发者编写的逻辑在封装后是和组件绑定在一起的，这就使得类组件内部的逻辑难以实现拆分和复用
   * 函数式组件--呼应react设计思想的“轻巧快艇”
     * ==函数组件会捕获render内部的状态，这是两者最大的不同==
   * Hooks的本质：一套能使函数组件更强大、更灵活的“钩子”
7. Hooks如何帮助我们升级工作模式的？
   * 告别难以理解的class
   * 解决业务逻辑难以拆分的问题
   * 使状态逻辑复用变得简单可行
   * 函数组件从设计思想上来看更加契合react的理念
   * hooks能帮助我们实现业务逻辑的聚合，避免复杂的组件和冗余的代码
   * 类组件的逻辑复用靠的是HOC和render props这些组件设计模式，他们在使用时也破坏者组件的结构，其中最常见的问题就是“嵌套地狱”现象
   * 当然Hooks并非万能，凡是都具有两面性 
8. react的使用原则？
   * 只在React函数中调用Hook
   * 不要在循环、条件、或嵌套函数中调用Hook
   * ==要确保Hooks在每次渲染时都保持同样的执行顺序==
9. react选择虚拟DOM是真的为了性能吗？
   * 虚拟dom是开发者为了追求更好的研发体验和研发效率而创造出来的高阶产物
   * 他的意义在于，能够在提供更高效的研发模式的同时，仍然保持一个还不错的性能
10. 虚拟dom的价值是什么呢？
    * 研发体验和研发效率
    * 跨平台
11. stack 调和是怎样的？
    * “调和”：虚拟dom映射到真实dom的过程（使一致的过程)
    * “Diff”: 找不同的过程
    * 栈调和即react 15中的diff算法：
      * 若两个组件属于同一类型，则具有相同的DOM树结构
      * 处于同一层级的一组子节点，可以通过设置key作为标识
      * 不比较垮层级节点
12. setState到底是同步还是异步的？
    * react中每来一个setState，就把它塞进一个队列里存起来，等时机成熟，再把存储的结果做合并，最后只针对最新的state值走一次更新（批量更新）
    * 在setTimeout、setInterval、DOM原生事件中表现为同步：
      * 并不是setTimeout将setState变为同步，而是==setTimeout帮助setState"逃脱"了react对它的管控==，只要是在react下 ，setState都是异步的。
13. Fiber架构的设计思想？
    * 栈调和的局限：
      * js线程和ui线程互斥，js对主线程的超时占用造成页面卡顿
      * 栈调和下的Diff算法，其实是树的深度优先遍历过程
    * fiber如何解决问题的？
      * 架构角度：是react核心算法的重写
      * 编码角度：react内部定义的一种数据结构
      * 工作流角度：fiber保存了组件需要更新的状态和副作用
      * fiber架构的意义是实现“增量渲染”
      * “可中断” “可恢复”  “优先级”
14. ReactDOM.render是如何串联渲染链路的？
    * 

