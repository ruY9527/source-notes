# Mysql事务

## ACID属性

- 原子性(Atomic)：事务的操作是不可分割的；事务只存在已执行和未执行两种状态，不存在只执行了部分指令的情况
- 一致性(Consistency)：在事务开始和事务结束以后，数据的完整性没有被破坏。
- 隔离性(Isolation)：同时执行的事务之间相互隔离，不会互相影响
- 持久性(Durability)：事务提交成功后，其写入的数据直到被覆盖永久有效

Mysql的原子性是通过undo log来实现，事务的持久是通过undo log实现，事务的隔离是通过读写锁+MVCC实现

## 事务隔离级别

- Read Uncommitted(读未提交): 禁止多个事务同时修改同一条记录，其它事务可以读取未提交的修改。 隔离级别最低，并发性能最高，会出现脏读，不可重复读和幻读
- Read Committed(读已提交): 禁止多个事务同时修改同一条记录, 修改在提交前其它事务只能读取修改前的版本。不会出现脏读，但会出现不可重复读和幻读
- Repeated Read(可重复读): 禁止多个事务同时修改同一条记录, 事务提交前会锁定所有读取到的行，禁止其它事务修改它正在读取的行。默认隔离级别，不会出现脏读和不可重复读。
- Serializable: 串行化执行，会锁定所有涉及的数据表。可以解决脏读、不可重复读和幻读， 隔离级别最高，并发性能最低

## 并发事务问题

- 脏读: 事务A修改了一个数据，但是没有提交，事务B读到了事务A未提交的更新结果（即脏数据）。如事务A在执行转账操作，从转出账户扣除了余额但未修改转入账户余额，此时事务B读取了转入账户的余额，即发生了脏读
- 不可重复读: 在同一个事务中，对于同一条数据两次查询读到的结果不一致。比如，在事务A两次查询中间事务B修改了某条记录，那么事务A两次查询会读到不同的结果
- 幻读: 在同一个事务中，对于同一个查询返回的记录数不一致。造成这种现象的原因是在事务A的两次查询中间事务B添加或删除了记录，导致事务A两次查询读到不同的结果

幻读和不可重复读区别：不可重复读是对已经存在的记录修改导致的只需要对某一条记录加锁即可；幻读增删记录导致的必须对全表加锁