# 参考地址
[https://www.qiancheng.me/post/coding/mysql-001](https://www.qiancheng.me/post/coding/mysql-001)
[https://joonwhee.blog.csdn.net/article/details/106893197](https://joonwhee.blog.csdn.net/article/details/106893197)
# 事务特征

- 原子性: 一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样，就好比买一件商品，购买成功时，则给商家付了钱，商品到手；购买失败时，则商品在商家手中，消费者的钱也没花出去
- 一致性: 是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。比如，用户 A 和用户 B 在银行分别有 800 元和 600 元，总共 1400 元，用户 A 给用户 B 转账 200 元，分为两个步骤，从 A 的账户扣除 200 元和对 B 的账户增加 200 元。一致性就是要求上述步骤操作后，最后的结果是用户 A 还有 600 元，用户 B 有 800 元，总共 1400 元，而不会出现用户 A 扣除了 200 元，但用户 B 未增加的情况（该情况，用户 A 和 B 均为 600 元，总共 1200 元）
- 隔离性: 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。也就是说，消费者购买商品这个事务，是不影响其他消费者购买的
- 持久性: 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失

Innodb引擎通过如下技术实现:

- 持久性 通过 redo log 实现
- 原子性 通过 redo log 实现
- 隔离性 通过 MVCC（多版本并发控制）或锁机制来实现
- 一致性:  持久性 + 原子性 + 隔离性 来保证的
# 事务隔离级别
主要用于解决脏读，不可重复读，幻读

- 脏读：一个事务读取到另外一个还未提交的事务
- 不可重复读：在一个事务中多次读取同一个数据时，结果出现不一致情况
- 幻读：在一个事务使用相同的SQL两次读取，第二次读取到其它事务新插入的行
| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
| --- | --- | --- | --- |
| 读未提交（Read Uncommitted） | 有 | 有 | 有 |
| 读已提交（Read Committed） | 没有 | 有 | 有 |
| 可重复读（Repeatable Read） | 没有 | 没有 | 有 |
| 串行化（Serializable） | 没有 | 没有 | 没有 |

# 可重复读工作
使用MVCC实现的,Mutil-Version Concurrency  Control,多版本并发控制。
InnoDB在每行记录后保存两个隐藏队列，分别保存了数据行的创建版本号和删除版本号。每开始一个新的事务，系统版本号都会递增。事务开始时刻的版本号会作为事务的版本号，用来和查询的每行记录的版本号对比。
MVCC只作用于RC(Read Committed) 和 RR（Repeatable Read）级别，因为RU总是读取最新的数据版本，而不是符合当前事务版本的数据行。
可重复读级别：

1. SELECT：必须同时满足以后两个条件,才能查询到。1.只查版本号早于当前版本的数据行；2.行的删除版本要么定义，要么大于当前事务的版本
2. INSERT：为插入的每一行保存当前系统版本号为创建版本号
3. DELETE：为删除的每一行保存当前系统版本号作为删除版本号
4. UPDATE：插入一条新数据，保存当前系统版本号作为创建版本号。同时保存当前系统版本号作为原来的数据行删除版本号

InnoDB会在每行记录后面增加三个隐藏字段
DB_ROW_ID: 行id,随着插入新行而单调递增,如果有主键的话,则不会包含该列
DB_TRX_ID: 记录插入或更新该行的事务的事务ID
DB_ROLL_PTR：回滚指针,指向undo log记录。每次对某条记录进行改动的时候，该列会存在一个指针，可以通过这个指针找到修改该记录修改前的信息。当某条记录被多次修改时，该行记录会存在多个版本，通过DB_ROL_PTR链形成一个版本链的概念
![](https://cdn.nlark.com/yuque/0/2023/png/316533/1679391809681-34d3c369-19f1-470f-b0e8-2c063a165dc4.png#averageHue=%23f6f3ef&clientId=ue63977c7-bd51-4&from=paste&id=u3be651a9&originHeight=278&originWidth=524&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u00f045bb-fbd3-4318-bdfc-4693d176c01&title=)

PR为例子：当开启一个事务时，系统会给该事务分配一个事务id，在该事务执行第一个select语句的时候，会生成一个当前时间点的事务快照 ReadView,主要包括以下几个属性:

- trx_ids: 生成 ReadView时，当前系统中活跃的事务id列表，就是还未执行事务提交的
- up_limit_id: 低水位，取 trx_ids 中最小的那个，trx_id小于该值的都可以看到
- low_limit_id: 高水位,生成ReadView时系统将要分配给下一个事务的id值，trx_id大于等于该值的都不能看到
- creator_trx_id: 生成该ReadView的事务的事务id

有了 ReadView,在访问某条记录的时候，就可以根据如下判断：

1. 如果访问的trx_id和ReadView的creator_trx_id是相同的,意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问
2. 如果被访问版本trx_id小于ReadView的up_limit_id值，表明生成该版本的事务在当前事务生成ReadView前已经提交了,所以该版本可以被当前事务范围
3. 如果被访问的trx_id大于ReadView中的low_limit_id值，表明生成该版本的事务在当前事务生成ReadView后才开启,所以该版本不可以被当前事务访问
4. 如果被访问版本的trx_id属性值在ReadView的up_limit_id和low_limit_id之间，那就需要判断一下trx_id属性值是不是在trx_ids列表中。如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问

![](https://cdn.nlark.com/yuque/0/2023/png/316533/1679397722509-240ecfaf-83f4-46b0-8e4b-77c8ad0c5957.png#averageHue=%23ccd1b8&clientId=ue63977c7-bd51-4&from=paste&id=ud3e0b425&originHeight=437&originWidth=900&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u7a2b9461-f2bd-4946-9e9c-b6ef826a86f&title=)
针对幻读：

- 快照读(普通select)：通过MVCC方法解决了幻读，因为可重复读隔离级别下，事务执行过程中看到数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其它事务插入一条数据，是查询不出来这条数据来的，可以很好的避免幻读
- 当前读（select for update等语句），是通过 next-key lock(记录锁 + 间隙锁)方法解决了幻读，因为当执行select...for update语句的时候，会加上next-key lock，如果有其它事务在next-key lock锁范围内插入一条记录，那么插入就会被阻塞，无法成功插入，所以就很好的避免了幻读
## 读提交和可重复读
对于 读提交 和 可重复读 隔离级别的事务来说，他们通过Read View来实现,区别在于创建 Read View的时机不同
读提交： 每个select都会生成一个新的ReadView，也意味着，事务期间的多次读取同一条数据，前后二次读的数据可能会出现不一致的，因为这个期间另外一个事务修改了该记录，并提交了事务
可重复读：启动时候生成一个ReadView,然后整个事务期间都在用这个Read View，这样保证了在事务期间读到数据都是事务启动前的事务
# undo log
回滚日志.
纪录数据被修改前的信息. undo log 主要记录是数据状态的逻辑变化,为了发生错误时回滚之前的操作,需要将之前的操作都记录下来，然后在发生错误时才回滚.
想要保证事务的原子性,就需要在异常发生时,对已经执行的操作进行回滚. 而在 MYSQL里,恢复机制就是通过 回滚日志(undo log)实现的.
如果整个系统发生崩溃,数据机进程直接被杀死后,当用户再次启动数据库进程时候,还能够立刻通过查询回滚日志将之前未完成的事务进行回滚,这也就需要回滚日志必须先于数据持久化到磁盘上,是我们需要先日志后写入数据的原因.
**逻辑日志,  **当回滚日志被使用时,它只会按照日志  逻辑地 将数据库中的修改撤销掉看, 可以理解为: 我们事务中使用的每一条 insert 都对应一条 delete, 每一条 update 对应一条方向的update

事务状态:

   - Active: 事务的初始状态,表示事务正在执行
   - Partially Commited: 在最后一条语句执行后
   - Failed: 发现事务无法正常执行之后
   - Aborted: 事务被回滚且数据库恢复到了事务进行之前的状态之后
   - Commited: 成功执行整个事务

级联回滚(Cascading Rollback)

当事务已经被提交之后,就无法再次回滚了,唯一能够撤回已经提交的事务方式就是创建一个相反的事务对原操作进行[补偿],这也是事务持久新的体现之一.
## MVCC
多版本并发控制.
# redo log
记录的是新数据备份. 在事务提交前,只要将redo log持久化即可,不需要将数据持久化.当系统崩溃时,虽然数据没持久化,但是Redo Log已经持久化了.系统可以根据 Redo log的内容,将所有数据恢复到最新的状态.
mysql 使用重做日志(redo log)实现事务的持久性,重做日志由两部分组成,  一是内存中的重做日志缓冲区,因为重做日志缓冲区在内存中,是易丢失的.  另一个就是在磁盘上的重做日志文件,它是持久的
重做日志都是以 512 字节的快的形式进行存储的,因为快的大小与磁盘扇区大小相同,所以重做日志的写入可以保证原子性，不会由于机器断电导致重做日志仅写入一半并留下脏数据





