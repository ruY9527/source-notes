# Mysql的buffer pool

## Buffer pool

Innodb为了缓存磁盘的页，在mysql服务器启动向操作系统申请了一片连续的内存，该内存叫 Buffer pool（缓冲池）。默认情况下 128M 大小。

查看大小指令

```sql
show variables like 'innodb_buffer_pool_size';
```

## 内部组成

Buffer pool中默认缓存页大小和磁盘上默认的页大小是一样的，16k。

为了更好的管理buffer pool的缓存页，innodb为每一个缓存页都创建了一些所谓的控制信息，这些控制信息包括页所属的表空间编号，页号，缓存页在buffer pool中的地址，链表节点信息，一些锁信息以及LSN信息，还有一些别的控制信息。

每个页缓存页对应的控制信息占用的内存大小是相同的，称为 控制块。控制块和缓存页是一一对应的，都被存放在buffer pool中

每个控制块占缓存页大小的5%

![bufferPool](./images/buffer_pool1.jpg)

## free链表

问题: 怎么区分Buffer Pool中那些缓存页是空闲的,那些是已经被使用了的呢?

​		  我们将所有空闲的缓存页对应的控制块作为一个节点,放在一个链表中,那么这个链表就可以被称作为free链表(空闲列表).

![空闲列表](./images/buffer_pool2.jpg)

## flush链表

如果我们修改了buffer pool中某个缓存页的数据,那它和磁盘上的页不一致了,这样的缓存页也成为 脏页(dirty page).

问题: 

- 如果每发生一次修改的话,就立刻同步到磁盘上对应的页上,但是频繁的往磁盘上中写数据会严重影响程序的性能.所以每次修改缓存页的时候,并不着急立刻把修改的同步到磁盘上,而是在未来某个时间点进行同步.
- 如果不立刻同步的话,那怎么区别buffer pool中那些页是脏页,那些页从来没被修改过呢?

所以就需要一个存储脏页的链表来进行记录,凡是修改过的缓存页对应的控制块,都作为一个节点加入到一个链表中,这个链表节点对应的缓存页都需要被刷新到磁盘上,所以也叫flush链表,其结构和free链表一样

![flush链表](./images/buffer_pool2.jpg)

## LRU链表(Least Recently Used)

问题:  Buffer Pool对应的内存大小也是有限的,如果缓存的页占用大小超过了Buffer Pool大小,也就是free链表中也没有多余的空闲缓存页时候,该怎么处理?

​           将旧的缓存页从buffer pool中移除,然后再将新的放入进来.

普通的LRU产生的问题:

- 容易出现预读失效

   预读(Read-Ahead),提前把页放入到缓冲池,但最终mysql并没有从页中读取数据,称为预读失败

- 容易出现缓冲池污染

  缓冲池污染: 当某一个sql的时候,要扫描大量数据时,可能导致缓冲池的所有页都替换出去,导致大量热数据被换出,mysql性能急剧下降,这种情况叫缓冲池污染

Mysql的buffer pool为了处理这2个问题,在普通的LRU基础上做了一些优化,尽量让真正的热点页可以在buffer pool里存活时间更长

Mysql的buffer pool处理方法: 头部的是新生代,尾部的是老生代

- 如果不在Buffer Pool中,在把该页从磁盘加载到Buffer Pool中的缓存页时,就把该缓存页对应的控制块作为节点放入LRU链表的头部
- 如果该缓存页存在Buffer Pool中,则直接把该页对应的控制块移动到LRU链表头部

只要我们使用到某个缓存页,就把该缓存页调整到LRU链表的头部,这样LRU链表尾部就是最近最少使用的缓存页,所以当Buffer Pool中的空闲缓存页使用完时,到LRU链表的尾部找些缓存页进行淘汰

## 刷新脏页到磁盘

1. 从LRU链表的冷数据中刷新一部分缓存页到磁盘.

   从LRU尾部开始扫描一些缓存页,扫描的缓存页数量可以通过系统变量innodb_lru_scan_depth来指定,如果从这里发现了脏页,会把他们刷新到磁盘.称为BUF_FLUSH_LRU

2. 从flush链表中刷新一部分页面到磁盘

   后台线程会定时从flush刷新一部分缓存页到磁盘,刷新的速率取决于当时系统是不是很繁忙.称为BUF_FLUSH_LIST

## 查看Buffer Pool的状态信息

```sql
show engine innodb status\G;
```

